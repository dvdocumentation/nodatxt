.. NodaLogic documentation master file, created by
   sphinx-quickstart on Wed Nov  5 07:29:33 2025.
   You can adapt this file completely to your liking, but it should at least
   contain the root `toctree` directive.

Client side (mobile and web client)
============================================

Capabilities and differences between the web client and the mobile client
--------------------------------------------------------------------------

Both clients share the same approaches and the same syntax; however, due to platform specifics, there are differences in UI behavior, available device features, and the execution environment.

Repository
~~~~~~~~~~

A configuration repository is a local storage of configurations (configs). The client can load multiple configurations at the same time; all loaded configurations are active simultaneously. Classes typically live in separate sections and do not interfere with each other.

Working with multiple rooms and room registration
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Rooms are used for online synchronization and delivery of node changes. A device registers in one or more rooms (via WebSocket). A room can be used to:

 * deliver node updates to clients
 * broadcast commands/events
 * implement request/response patterns (including remote execution on clients)

Covers for mobile and web clients
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A **cover** is a short representation of a node in lists (title, subtitle, icon, status, etc.). Covers are configured per class; the same class may define different cover representations for mobile and web.

Active covers
~~~~~~~~~~~~~

An **active cover** supports actions directly in the list (buttons, switches, etc.). When the user interacts with such elements, the node receives extended input data: list name, element name, item position, and, for input elements, value.

Standard commands
~~~~~~~~~~~~~~~~~

Standard commands are built-in actions recognized by clients (open node, back, refresh, scan, etc.). They are used in buttons, list actions, and menus.

Users
~~~~~

Users can be configured and used for authentication/authorization scenarios (depending on server settings). The client may store credentials and send them with requests to the server.

Working with a hardware barcode scanner
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Mobile clients can work with hardware scanners. Scanner events can be mapped into ``onInput``/``onInputWeb`` to unify handling logic.

Common functions of the mobile and web client
---------------------------------------------

General structure of UI and events
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

User interaction triggers events. Events carry a ``listener``; handlers are subscribed by listener match. Handlers are Python methods defined in node classes.

Principles of screen markup and other visual forms
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Screen markup is a JSON-like layout consisting of rows and elements. Elements have ``type`` and other properties. Data binding is done via ``@field`` references to ``_data``.

Static and dynamic markup of a node form
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Markup can be static (defined in config) or dynamic (generated by code at runtime). Dynamic update can be done either by full redraw (``Show``) or incremental update (``UpdateView``).

Types of visual objects and their unique properties
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Label
~~~~~

Simple text element. Can render static text or text from ``_data`` (``"value":"@title"``). Supports formatting options.

Image
~~~~~

Image element; can render from URL or from a resource. Supports sizing and alignment.

HTML field
~~~~~~~~~~

Renders HTML content. Useful for rich representation, templates, and embedded formatting.

Button
~~~~~~

Clickable element that triggers ``onInput``. Supports captions, icons, and command payload.

Bottom buttons list
~~~~~~~~~~~~~~~~~~~

A special area of persistent action buttons at the bottom of the screen (mobile-first UI pattern).

Switch
~~~~~~

Boolean toggle. On change, triggers input event and writes value into ``_data``.

Checkbox
~~~~~~~~

Checkbox input; similar to switch but with different UI representation.

Lists
~~~~~

Lists render arrays of items. Items can be simple strings or structured objects. Lists support selection, active elements, and custom templates.

Displaying a list as a table
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Table mode renders list items in columns. Useful for dense data presentation.

List of child nodes
~~~~~~~~~~~~~~~~~~~

A built-in list type that shows child nodes of the current node (hierarchy).

Tabs/Pages
----------

Tabs allow splitting a form into multiple pages. Each page has its own layout. Switching tabs does not necessarily recreate the node.

Input fields
~~~~~~~~~~~~

Input elements write values into ``_data`` and trigger ``onInput``/``onInputWeb``.

Dropdown list
~~~~~~~~~~~~~

Select one value from a list (fixed or loaded). Can show labels, codes, and apply filtering.

Node input field
~~~~~~~~~~~~~~~~

Allows selecting another node as a value (a reference). Returned/assigned value format is ``<class_name>$<node_id>``.

Dataset input fields
~~~~~~~~~~~~~~~~~~~~

Allows selecting a dataset item (reference or document). Representation is defined by a dataset record template; HTML is allowed.

Labels without an object
~~~~~~~~~~~~~~~~~~~~~~~~

In markup, a string can be used instead of an object with ``type=Text``. If the string starts with ``@``, it is resolved from ``_data``. The ``<title>|<value>`` format renders as a titled card.

Example of hiding a node
~~~~~~~~~~~~~~~~~~~~~~~~

``self._data["_hidden"] = True``
